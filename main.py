
import cv2
import os
import tempfile
import re
import string
import time
import asyncio
import numpy as np
from telegram import Update
from telegram.constants import ChatAction
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters
from fpdf import FPDF
from PIL import Image
import yt_dlp
from skimage.metrics import structural_similarity as ssim
from threading import Semaphore
from concurrent.futures import ThreadPoolExecutor
import threading

# Your Telegram Bot Token - Get from environment variable with fallback
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', '7960013115:AAEocB5fZ6jxLZVIcWwMVd5bJd-oQNqdEfA')

# Channel ‡§ï‡•Ä settings
CHANNEL_USERNAME = '@alluserpdf'  # ‡§Ü‡§™‡§ï‡§æ channel username

# SSIM ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏
SSIM_THRESHOLD = 1  # ‡§∏‡§Æ‡§æ‡§®‡§§‡§æ ‡§ï‡§æ ‡§•‡•ç‡§∞‡•á‡§∂‡•ã‡§≤‡•ç‡§°
SSIM_RESIZE_DIM = (128, 72) # SSIM ‡§§‡•Å‡§≤‡§®‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ï‡§æ ‡§Ü‡§ï‡§æ‡§∞
FRAME_SKIP_FOR_SSIM_CHECK = 500 # ‡§π‡§∞ 3rd ‡§´‡•ç‡§∞‡•á‡§Æ ‡§™‡§∞ SSIM ‡§ú‡§æ‡§Ç‡§ö

# PDF ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏
PDF_FRAME_WIDTH_TARGET = 1280 # PDF ‡§Æ‡•á‡§Ç ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ï‡•Ä ‡§ö‡•å‡§°‡§º‡§æ‡§à
WATERMARK_TEXT = "Created by @youpdf_bot"
MAX_PDF_PAGES = 5000 # PDF ‡§Æ‡•á‡§Ç ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ ‡§™‡•á‡§ú

# Multi-user processing ‡§ï‡•á ‡§≤‡§ø‡§è settings
MAX_CONCURRENT_USERS = 10
CHUNK_DURATION_MINUTES = 30  # 30 ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á chunks
MAX_VIDEO_DURATION_HOURS = 1.5 # ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ 1.5 ‡§ò‡§Ç‡§ü‡•á

# Semaphore for limiting concurrent processing
processing_semaphore = Semaphore(MAX_CONCURRENT_USERS)
user_queue = []
processing_users = {}  # Changed to dict to store user processing info

def get_video_id(url):
    """YouTube URL ‡§∏‡•á video ID extract ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"""
    video_id_match = re.search(r"(?:v=|\/)([0-9A-Za-z_-]{11})", url)
    if video_id_match:
        return video_id_match.group(1)
    return None

def sanitize_filename(title):
    """File name ‡§ï‡•ã safe ‡§¨‡§®‡§æ‡§§‡§æ ‡§π‡•à"""
    return ''.join(c for c in title if c in (string.ascii_letters + string.digits + ' -_')).rstrip()

def format_duration(seconds):
    """Duration ‡§ï‡•ã proper format ‡§Æ‡•á‡§Ç convert ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"""
    if seconds < 60:
        return f"{int(seconds)}s"
    elif seconds < 3600:
        minutes = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{minutes}m {secs}s"
    else:
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        return f"{hours}h {minutes}m"

def get_video_duration(video_id):
    """Video ‡§ï‡•Ä duration ‡§®‡§ø‡§ï‡§æ‡§≤‡§§‡§æ ‡§π‡•à"""
    video_url = f"https://www.youtube.com/watch?v={video_id}"
    ydl_opts = {
        'quiet': True,
        'no_warnings': True,
        'cookiefile': 'cookies.txt',
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        try:
            info_dict = ydl.extract_info(video_url, download=False)
            duration = info_dict.get('duration', 0)  # seconds ‡§Æ‡•á‡§Ç
            return duration
        except:
            return 0

def download_video(video_id, progress_callback=None):
    """YouTube video download ‡§ï‡§∞‡§§‡§æ ‡§π‡•à with better control"""
    video_url = f"https://www.youtube.com/watch?v={video_id}"
    output_file = f"video_{video_id}.mp4"
    
    # Clean console output
    def progress_hook(d):
        if progress_callback and d['status'] == 'downloading':
            try:
                percent = d.get('_percent_str', 'N/A').strip()
                speed = d.get('_speed_str', 'N/A').strip()
                if progress_callback:
                    progress_callback(percent, speed)
            except:
                pass
    
    ydl_opts = {
        'format': 'best[height<=720]/best',
        'outtmpl': output_file,
        'noplaylist': True,
        'quiet': True,
        'no_warnings': True,
        'progress_hooks': [progress_hook],
        'retries': 5,
        'fragment_retries': 5,
        'extractaudio': False,
        'keepvideo': True,
        'cookiefile': 'cookies.txt',
    }
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(video_url, download=True)
            title = info_dict.get('title', 'Unknown Title')
            duration = info_dict.get('duration', 0)
            
            if not os.path.exists(output_file):
                raise Exception("Video file download failed")
                
            return title, output_file, duration
            
    except Exception as e:
        if os.path.exists(output_file):
            try:
                os.remove(output_file)
            except:
                pass
        raise Exception(f"Download failed: {str(e)}")

def extract_unique_frames_for_chunk(video_file, output_folder, start_time, end_time, chunk_num, n=3, ssim_threshold=0.8):
    """Video ‡§ï‡•á specific chunk ‡§∏‡•á unique frames extract ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"""
    cap = cv2.VideoCapture(video_file)
    fps = int(cap.get(cv2.CAP_PROP_FPS))
    
    start_frame = int(start_time * fps)
    end_frame = int(end_time * fps)
    
    cap.set(cv2.CAP_PROP_POS_FRAMES, start_frame)
    
    last_frame = None
    saved_frame = None
    frame_number = start_frame
    last_saved_frame_number = -1
    timestamps = []

    while frame_number < end_frame and cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        if (frame_number - start_frame) % n == 0:
            frame = cv2.resize(frame, (640, 360), interpolation=cv2.INTER_CUBIC)
            gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            gray_frame = cv2.resize(gray_frame, (128, 72))

            if last_frame is not None:
                try:
                    data_range = gray_frame.max() - gray_frame.min()
                    if data_range > 0:
                        similarity = ssim(gray_frame, last_frame, data_range=data_range)
                    else:
                        similarity = 1.0
                except Exception as e:
                    similarity = 0.0

                if similarity < ssim_threshold:
                    if saved_frame is not None and frame_number - last_saved_frame_number > fps:
                        frame_path = os.path.join(output_folder, f'chunk{chunk_num}_frame{frame_number:04d}_{frame_number // fps}.png')
                        cv2.imwrite(frame_path, saved_frame, [int(cv2.IMWRITE_PNG_COMPRESSION), 3])
                        timestamps.append((frame_number, frame_number // fps))

                    saved_frame = frame
                    last_saved_frame_number = frame_number
                else:
                    saved_frame = frame
            else:
                frame_path = os.path.join(output_folder, f'chunk{chunk_num}_frame{frame_number:04d}_{frame_number // fps}.png')
                cv2.imwrite(frame_path, frame, [int(cv2.IMWRITE_PNG_COMPRESSION), 3])
                timestamps.append((frame_number, frame_number // fps))
                last_saved_frame_number = frame_number

            last_frame = gray_frame

        frame_number += 1

    cap.release()
    return timestamps

def convert_frames_to_pdf_chunk(input_folder, output_file, timestamps, chunk_num):
    """Specific chunk ‡§ï‡•á frames ‡§ï‡•ã PDF ‡§Æ‡•á‡§Ç convert ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"""
    frame_files = [f for f in os.listdir(input_folder) if f.startswith(f'chunk{chunk_num}_')]
    frame_files = sorted(frame_files, key=lambda x: int(x.split('_')[1].split('frame')[-1]))
    
    pdf = FPDF("L")
    pdf.set_auto_page_break(0)

    total_pages = 0

    for i, (frame_file, (frame_number, timestamp_seconds)) in enumerate(zip(frame_files, timestamps)):
        frame_path = os.path.join(input_folder, frame_file)
        if not os.path.exists(frame_path):
            continue
            
        image = Image.open(frame_path)

        pdf.add_page()
        total_pages += 1

        width, height = image.size
        pdf_width = pdf.w
        pdf_height = pdf.h

        aspect_ratio = width / height
        new_width = pdf_width
        new_height = pdf_width / aspect_ratio

        if new_height > pdf_height:
            new_height = pdf_height
            new_width = pdf_height * aspect_ratio

        x = (pdf_width - new_width) / 2
        y = (pdf_height - new_height) / 2

        pdf.image(frame_path, x=x, y=y, w=new_width, h=new_height)

        timestamp = f"{timestamp_seconds // 3600:02d}:{(timestamp_seconds % 3600) // 60:02d}:{timestamp_seconds % 60:02d}"
        watermark_text = "Created by @youpdf_bot"
        combined_text = f"{timestamp} - {watermark_text}"

        pdf.set_xy(5, 5)
        pdf.set_font("Arial", size=18)
        pdf.cell(0, 0, combined_text)

    if total_pages > 0:
        pdf.output(output_file)
    return total_pages

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command handler"""
    user_name = update.effective_user.first_name
    user_id = update.effective_user.id
    username = update.effective_user.username or "No username"

    welcome_message = f"""
üëã ‡§®‡§Æ‡§∏‡•ç‡§§‡•á {user_name}!

üé¨ YouTube to PDF Bot ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à!

üìã ‡§ï‡•à‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à:
1. YouTube video ‡§ï‡§æ link ‡§≠‡•á‡§ú‡•á‡§Ç 
2. Bot video ‡§ï‡•ã 30-30 ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á ‡§≠‡§æ‡§ó‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§¨‡§æ‡§Ç‡§ü‡•á‡§ó‡§æ
3. ‡§π‡§∞ ‡§≠‡§æ‡§ó ‡§ï‡•Ä PDF ‡§¨‡§®‡§ï‡§∞ ‡§§‡•Å‡§∞‡§Ç‡§§ ‡§≠‡•á‡§ú‡•Ä ‡§ú‡§æ‡§è‡§ó‡•Ä
4. ‡§è‡§ï ‡§∏‡§æ‡§• 10 users ‡§ï‡•Ä videos process ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à‡§Ç


üö® Bot ‡§ï‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•á ‡§Ö‡§≤‡§æ‡§µ‡§æ ‡§ï‡•ã‡§à ‡§î‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§® ‡§ï‡§∞‡•á‡§Ç 
‡§Ø‡§π ‡§Æ‡•à‡§∏‡•á‡§ú Owner ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ‡§§‡§æ ‡§π‡•à
üìû Contact Owner - @LODHIJI27

‡§¨‡§∏ YouTube link ‡§≠‡•á‡§ú‡§ø‡§è! üöÄ

‚ö†Ô∏è ‡§®‡•ã‡§ü: ‡§ï‡•á‡§µ‡§≤ 1.5 ‡§ò‡§Ç‡§ü‡•á ‡§§‡§ï ‡§ï‡•Ä videos ‡§π‡•Ä process ‡§π‡•ã‡§Ç‡§ó‡•Ä
    """

    await update.message.reply_text(welcome_message)

    # Forward original message to channel
    try:
        await update.message.forward(chat_id=CHANNEL_USERNAME)
        
        # Additional info message for channel
        channel_message = f"""
üÜï ‡§®‡§Ø‡§æ User Bot ‡§ï‡•ã Start ‡§ï‡§ø‡§Ø‡§æ!

üë§ Name: {user_name}
üÜî User ID: {user_id}
üìù Username: @{username}
‚è∞ Time: {time.strftime('%Y-%m-%d %H:%M:%S')}
        """
        await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_message)
    except Exception as e:
        print(f"Channel message send error: {e}")

async def process_video_chunks(update, context, video_id, title, video_path, user_name, user_id, username, url, duration_seconds):
    """Video ‡§ï‡•ã chunks ‡§Æ‡•á‡§Ç process ‡§ï‡§∞‡§§‡§æ ‡§π‡•à ‡§î‡§∞ ‡§π‡§∞ chunk ‡§ï‡•Ä PDF instantly ‡§≠‡•á‡§ú‡§§‡§æ ‡§π‡•à"""
    messages_to_delete = []  # Track messages to delete
    start_time = time.time()
    
    try:
        chunk_duration_seconds = CHUNK_DURATION_MINUTES * 60
        total_chunks = int(np.ceil(duration_seconds / chunk_duration_seconds))
        
        analysis_msg = await update.message.reply_text(
            f"üìä Video Analysis:\n"
            f"üé¨ Title: {title}\n"
            f"‚è±Ô∏è ‡§ï‡•Å‡§≤ ‡§∏‡§Æ‡§Ø: {format_duration(duration_seconds)}\n"
            f"üì¶ ‡§ï‡•Å‡§≤ ‡§≠‡§æ‡§ó: {total_chunks}\n\n"
            f"üîÑ Processing ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à..."
        )
        
        # Forward analysis to channel
        try:
            await analysis_msg.forward(chat_id=CHANNEL_USERNAME)
        except:
            pass

        total_pages_all = 0

        with tempfile.TemporaryDirectory() as temp_folder:
            for chunk_num in range(total_chunks):
                start_time_chunk = chunk_num * chunk_duration_seconds
                end_time_chunk = min((chunk_num + 1) * chunk_duration_seconds, duration_seconds)
                
                chunk_start_min = int(start_time_chunk // 60)
                chunk_end_min = int(end_time_chunk // 60)
                
                # Better progress message
                processing_msg = await update.message.reply_text(
                    f"üîÑ Processing Part {chunk_num + 1}/{total_chunks}\n"
                    f"üìç Video portion: {format_duration(start_time_chunk)} - {format_duration(end_time_chunk)}\n"
                    f"‚öôÔ∏è Extracting frames..."
                )
                messages_to_delete.append(processing_msg)
                
                # Forward processing update to channel
                try:
                    await processing_msg.forward(chat_id=CHANNEL_USERNAME)
                except:
                    pass
                
                # Frames extract ‡§ï‡§∞‡§®‡§æ
                timestamps = extract_unique_frames_for_chunk(
                    video_path, temp_folder, start_time_chunk, end_time_chunk, chunk_num, 
                    n=FRAME_SKIP_FOR_SSIM_CHECK, ssim_threshold=SSIM_THRESHOLD
                )
                
                if not timestamps:
                    await update.message.reply_text(f"‚ö†Ô∏è Part {chunk_num + 1}: ‡§ï‡•ã‡§à unique frames ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•á")
                    continue
                
                # PDF ‡§¨‡§®‡§æ‡§®‡§æ
                try:
                    await processing_msg.edit_text(
                        f"üîÑ Processing Part {chunk_num + 1}/{total_chunks}\n"
                        f"üìç Video portion: {format_duration(start_time_chunk)} - {format_duration(end_time_chunk)}\n"
                        f"üìÑ Creating PDF... ({len(timestamps)} frames)"
                    )
                except:
                    pass
                
                # Chunk ‡§ï‡§æ filename
                safe_title = sanitize_filename(title)[:50]
                chunk_filename = f"{safe_title}_Part{chunk_num + 1}_of_{total_chunks}.pdf"
                chunk_pdf_path = os.path.join(temp_folder, chunk_filename)
                
                # PDF convert ‡§ï‡§∞‡§®‡§æ
                pages_in_chunk = convert_frames_to_pdf_chunk(temp_folder, chunk_pdf_path, timestamps, chunk_num)
                total_pages_all += pages_in_chunk
                
                if pages_in_chunk > 0 and os.path.exists(chunk_pdf_path):
                    # PDF ‡§≠‡•á‡§ú‡§®‡§æ
                    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.UPLOAD_DOCUMENT)
                    
                    chunk_caption = f"""
‚úÖ Part {chunk_num + 1}/{total_chunks} Complete!

üé¨ Title: {title}
üìÑ Pages: {pages_in_chunk}
‚è±Ô∏è Time Range: {format_duration(start_time_chunk)} - {format_duration(end_time_chunk)}
üì¶ Frames: {len(timestamps)}

üìû Bot by @LODHIJI27
                    """
                    
                    with open(chunk_pdf_path, 'rb') as pdf_file:
                        await update.message.reply_document(
                            document=pdf_file,
                            filename=chunk_filename,
                            caption=chunk_caption
                        )
                    
                    # Send to channel
                    try:
                        channel_update = f"""
üì§ PDF Part Sent!

üë§ User: {user_name} (@{username})
üÜî ID: {user_id}
üé¨ Video: {title}
üìÑ Part {chunk_num + 1}/{total_chunks} - {pages_in_chunk} pages
‚è±Ô∏è Time: {format_duration(start_time_chunk)}-{format_duration(end_time_chunk)}
üîó URL: {url}
                        """
                        await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_update)
                    except:
                        pass
                
                # Cleanup chunk frames
                for frame_file in os.listdir(temp_folder):
                    if frame_file.startswith(f'chunk{chunk_num}_'):
                        try:
                            os.remove(os.path.join(temp_folder, frame_file))
                        except:
                            pass
                
                # Delete processing message
                try:
                    await processing_msg.delete()
                except:
                    pass

        # Final completion message
        total_processing_time = time.time() - start_time
        completion_msg = f"""
üéâ ‡§∏‡§≠‡•Ä Parts Complete!

üé¨ Title: {title}
üìä Total Pages: {total_pages_all}
üì¶ Total Parts: {total_chunks}
‚è±Ô∏è Processing Time: {format_duration(total_processing_time)}

üë®‚Äçüíª Bot by @LODHIJI27
        """
        
        await update.message.reply_text(completion_msg)
        
        # Send completion to channel
        try:
            channel_completion = f"""
‚úÖ Complete Video Processing!

üë§ User: {user_name} (@{username})
üÜî ID: {user_id}
üé¨ Video: {title}
üìä Total: {total_pages_all} pages, {total_chunks} parts
‚è±Ô∏è Time: {format_duration(total_processing_time)}
üîó URL: {url}
            """
            await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_completion)
        except:
            pass

    except Exception as e:
        error_msg = f"‚ùå Error during processing: {str(e)}"
        await update.message.reply_text(error_msg)
        print(f"Chunk processing error: {e}")

    finally:
        # Clean up video file
        try:
            if os.path.exists(video_path):
                os.remove(video_path)
        except:
            pass

async def handle_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """YouTube URL handle ‡§ï‡§∞‡§§‡§æ ‡§π‡•à"""
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    username = update.effective_user.username or "No username"
    url = update.message.text.strip()
    
    # Check if user is already processing
    if user_id in processing_users:
        await update.message.reply_text(
            f"‚ö†Ô∏è {user_name}, ‡§Ü‡§™‡§ï‡•Ä ‡§è‡§ï video ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä process ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à!\n"
            f"‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡§π‡§≤‡•Ä video ‡§ï‡§æ processing complete ‡§π‡•ã‡§®‡•á ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§"
        )
        return
    
    # YouTube URL validation
    if not re.search(r'(youtube\.com|youtu\.be)', url):
        await update.message.reply_text(
            "‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ valid YouTube link ‡§≠‡•á‡§ú‡•á‡§Ç!\n\n"
            "Example:\n"
            "https://www.youtube.com/watch?v=VIDEO_ID\n"
            "https://youtu.be/VIDEO_ID"
        )
        return
    
    # Extract video ID
    video_id = get_video_id(url)
    if not video_id:
        await update.message.reply_text("‚ùå YouTube video ID extract ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§æ!")
        return
    
    # Check video duration first
    duration_seconds = get_video_duration(video_id)
    max_duration_seconds = MAX_VIDEO_DURATION_HOURS * 3600
    
    if duration_seconds == 0:
        await update.message.reply_text("‚ùå Video ‡§ï‡•Ä information ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä!")
        return
    
    if duration_seconds > max_duration_seconds:
        await update.message.reply_text(
            f"‚ùå Video ‡§¨‡§π‡•Å‡§§ ‡§≤‡§Ç‡§¨‡•Ä ‡§π‡•à!\n\n"
            f"üìè Video Duration: {format_duration(duration_seconds)}\n"
            f"üö´ Maximum Allowed: {format_duration(max_duration_seconds)}\n\n"
            f"‡§ï‡•É‡§™‡§Ø‡§æ {MAX_VIDEO_DURATION_HOURS} ‡§ò‡§Ç‡§ü‡•á ‡§∏‡•á ‡§ï‡§Æ ‡§ï‡•Ä video ‡§≠‡•á‡§ú‡•á‡§Ç‡•§"
        )
        return
    
    # Check if we can acquire semaphore (non-blocking)
    if not processing_semaphore.acquire(blocking=False):
        queue_position = len(user_queue) + 1
        user_queue.append(user_id)
        
        await update.message.reply_text(
            f"‚è≥ Queue ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§•‡§æ‡§®: {queue_position}\n\n"
            f"üîÑ ‡§Ö‡§≠‡•Ä {MAX_CONCURRENT_USERS} users ‡§ï‡•Ä videos process ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à‡§Ç‡•§\n"
            f"‚è∞ ‡§Ü‡§™‡§ï‡•Ä ‡§¨‡§æ‡§∞‡•Ä ‡§Ü‡§®‡•á ‡§™‡§∞ processing ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã‡§ó‡•Ä‡•§\n\n"
            f"‡§ï‡•É‡§™‡§Ø‡§æ ‡§•‡•ã‡§°‡§º‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç..."
        )
        
        # Wait for turn
        while user_id in user_queue and not processing_semaphore.acquire(blocking=False):
            await asyncio.sleep(5)
        
        if user_id in user_queue:
            user_queue.remove(user_id)
    
    # Add user to processing list
    processing_users[user_id] = {
        'video_id': video_id,
        'start_time': time.time(),
        'url': url
    }
    
    try:
        # Forward original URL message to channel
        try:
            await update.message.forward(chat_id=CHANNEL_USERNAME)
            
            # Additional info message for channel
            channel_message = f"""
üîó ‡§®‡§Ø‡§æ YouTube Link Received!

üë§ Name: {user_name}
üÜî User ID: {user_id}
üìù Username: @{username}
üé¨ Video ID: {video_id}
‚è±Ô∏è Duration: {format_duration(duration_seconds)}
üîó URL: {url}
‚è∞ Time: {time.strftime('%Y-%m-%d %H:%M:%S')}
            """
            await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_message)
        except Exception as e:
            print(f"Channel message send error: {e}")
        
        # Start processing
        await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)
        
        # Initial response
        progress_msg = await update.message.reply_text(
            f"üé¨ Video Processing ‡§∂‡•Å‡§∞‡•Ç...\n\n"
            f"üìã Video ID: {video_id}\n"
            f"‚è±Ô∏è Duration: {format_duration(duration_seconds)}\n"
            f"üì• Downloading video..."
        )
        
        # Download progress callback
        async def update_progress(percent, speed):
            try:
                await progress_msg.edit_text(
                    f"üé¨ Video Processing...\n\n"
                    f"üìã Video ID: {video_id}\n"
                    f"‚è±Ô∏è Duration: {format_duration(duration_seconds)}\n"
                    f"üì• Download Progress: {percent}\n"
                    f"üöÄ Speed: {speed}"
                )
            except:
                pass
        
        # Download video in thread to avoid blocking
        loop = asyncio.get_event_loop()
        
        def download_wrapper():
            return download_video(video_id, lambda p, s: asyncio.run_coroutine_threadsafe(update_progress(p, s), loop))
        
        with ThreadPoolExecutor() as executor:
            future = loop.run_in_executor(executor, download_wrapper)
            title, video_path, duration = await future
        
        # Update message after download
        try:
            await progress_msg.edit_text(
                f"‚úÖ Video Downloaded!\n\n"
                f"üé¨ Title: {title}\n"
                f"‚è±Ô∏è Duration: {format_duration(duration)}\n"
                f"üìÇ File: {video_path}\n\n"
                f"üîÑ Starting frame extraction..."
            )
        except:
            pass
        
        # Process video chunks
        await process_video_chunks(
            update, context, video_id, title, video_path, 
            user_name, user_id, username, url, duration
        )
        
    except Exception as e:
        error_message = f"‚ùå Error: {str(e)}"
        await update.message.reply_text(error_message)
        print(f"Processing error for user {user_id}: {e}")
        
        # Send error to channel
        try:
            channel_error = f"""
‚ùå Processing Error!

üë§ User: {user_name} (@{username})
üÜî ID: {user_id}
üé¨ Video ID: {video_id}
üîó URL: {url}
‚ùå Error: {str(e)}
‚è∞ Time: {time.strftime('%Y-%m-%d %H:%M:%S')}
            """
            await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_error)
        except:
            pass
    
    finally:
        # Clean up and release resources
        if user_id in processing_users:
            del processing_users[user_id]
        
        processing_semaphore.release()
        
        # Process next user in queue if any
        if user_queue:
            next_user = user_queue.pop(0)
            # The next user's handler will automatically acquire the semaphore

async def handle_other_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle non-URL messages"""
    user_name = update.effective_user.first_name
    
    await update.message.reply_text(
        f"üëã {user_name}, ‡§Æ‡•à‡§Ç ‡§ï‡•á‡§µ‡§≤ YouTube links process ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Ç!\n\n"
        f"üé¨ ‡§ï‡•É‡§™‡§Ø‡§æ YouTube video ‡§ï‡§æ link ‡§≠‡•á‡§ú‡•á‡§Ç‡•§\n\n"
        f"Example:\n"
        f"https://www.youtube.com/watch?v=VIDEO_ID\n"
        f"https://youtu.be/VIDEO_ID\n\n"
        f"üìû Help ‡§ï‡•á ‡§≤‡§ø‡§è: @LODHIJI27"
    )
    
    # Forward to channel for monitoring
    try:
        await update.message.forward(chat_id=CHANNEL_USERNAME)
        
        channel_message = f"""
üí¨ Other Message Received

üë§ User: {user_name}
üÜî ID: {update.effective_user.id}
üìù Username: @{update.effective_user.username or 'No username'}
üí¨ Message: {update.message.text[:100]}...
‚è∞ Time: {time.strftime('%Y-%m-%d %H:%M:%S')}
        """
        await context.bot.send_message(chat_id=CHANNEL_USERNAME, text=channel_message)
    except Exception as e:
        print(f"Channel forward error: {e}")

def main():
    """Main function to run the bot"""
    print("üöÄ YouTube to PDF Bot Starting...")
    print(f"üìä Max concurrent users: {MAX_CONCURRENT_USERS}")
    print(f"‚è±Ô∏è Chunk duration: {CHUNK_DURATION_MINUTES} minutes")
    print(f"üì∫ Max video duration: {MAX_VIDEO_DURATION_HOURS} hours")
    
    # Create bot application
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    
    # URL handler (YouTube links)
    url_filter = filters.Regex(r'(youtube\.com|youtu\.be)')
    application.add_handler(MessageHandler(url_filter, handle_url))
    
    # Other messages handler
    application.add_handler(MessageHandler(filters.TEXT & ~url_filter, handle_other_messages))
    
    print("‚úÖ Bot handlers registered")
    print("üîÑ Starting polling...")
    
    # Start the bot
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        drop_pending_updates=True
    )

if __name__ == '__main__':
    main()
